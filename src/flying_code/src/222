#include <ros/ros.h>
#include <geometry_msgs/PoseStamped.h>
#include <mavros_msgs/State.h>
#include <mavros_msgs/SetMode.h>
#include <mavros_msgs/CommandBool.h>
#include <mavros_msgs/CommandTOL.h>
#include <geometry_msgs/Vector3.h>
#include <mavros_msgs/PositionTarget.h>
#include <cmath>
#include <vector> // 引入 vector 容器

// ==========================================
// 1. 全局配置区 (Configuration)
// ==========================================

// --- 定义航点结构体 ---
struct Waypoint {
    double x;3
    
    double y;
    double z;
    double duration; 
};


const std::vector<Waypoint> MISSION_WAYPOINTS = {
    // { x,   y,   z,   time }
    { 1.5,  1.0,  3.0,  4.0 }, 
    { -1.5,  -1.5,  1.5,   5.0 }, 
    { 0.0,  1.5,  1.2,   3.0 }, 
    //{ 0.0,  0.0,  1.0,   3.0 } 
};

// --- 起飞参数 ---
const double TAKEOFF_HEIGHT = 1.0; // 起飞高度

// --- 其他时间参数 ---
const double TIME_HOVER  = 5.0;  // 任务全部完成后悬停时长 
const double TIME_WARMUP = 2.0;  // 起飞前预热时长

// ==========================================

enum TaskState {
    PREPARE,    
    TAKEOFF,    
    TRAJECTORY, // 多点轨迹规划
    HOLD,       
    LAND,       
    FINISHED    
};

mavros_msgs::State current_state;
geometry_msgs::PoseStamped current_pose;
bool has_pose_received = false; 

void state_cb(const mavros_msgs::State::ConstPtr& msg){ current_state = *msg; }
void pos_cb(const geometry_msgs::PoseStamped::ConstPtr& msg){
    current_pose = *msg;
    has_pose_received = true;
}

double calculate_yaw(const geometry_msgs::Quaternion& q) {
    double siny_cosp = 2.0 * (q.w * q.z + q.x * q.y);
    double cosy_cosp = 1.0 - 2.0 * (q.y * q.y + q.z * q.z);
    return std::atan2(siny_cosp, cosy_cosp);
}

// 五次多项式类
class QuinticPoly {
public:
    double a0, a1, a2, a3, a4, a5;
    void compute(double start, double end, double T) {
        if (T <= 0) T = 0.1;
        double T3 = T*T*T, T4 = T3*T, T5 = T4*T;
        a0 = start; a1 = 0; a2 = 0;
        a3 = (20*(end-start)) / (2*T3);
        a4 = (30*(start-end)) / (2*T4);
        a5 = (12*(end-start)) / (2*T5);
    }
    double get_pos(double t) { return a0 + a1*t + a2*t*t + a3*t*t*t + a4*t*t*t*t + a5*t*t*t*t*t; }
    double get_vel(double t) { return a1 + 2*a2*t + 3*a3*t*t + 4*a4*t*t*t + 5*a5*t*t*t*t; }
    double get_acc(double t) { return 2*a2 + 6*a3*t + 12*a4*t*t + 20*a5*t*t*t; }
};

int main(int argc, char **argv) {
    ros::init(argc, argv, "multi_waypoint_node");
    ros::NodeHandle nh;

    ros::Subscriber state_sub = nh.subscribe<mavros_msgs::State>("mavros/state", 10, state_cb);
    ros::Subscriber pos_sub = nh.subscribe<geometry_msgs::PoseStamped>("mavros/local_position/pose", 10, pos_cb);
    ros::Publisher target_pub = nh.advertise<mavros_msgs::PositionTarget>("mavros/setpoint_raw/local", 10);
    ros::ServiceClient set_mode_client = nh.serviceClient<mavros_msgs::SetMode>("mavros/set_mode");
    ros::ServiceClient arming_client = nh.serviceClient<mavros_msgs::CommandBool>("mavros/cmd/arming");
    ros::ServiceClient land_client = nh.serviceClient<mavros_msgs::CommandTOL>("mavros/cmd/land");

    ros::Rate rate(20.0);

    ROS_INFO("Waiting for FCU connection...");
    while(ros::ok() && !current_state.connected){ ros::spinOnce(); rate.sleep(); }
    
    ROS_INFO("Waiting for Position Data...");
    while(ros::ok() && !has_pose_received){ ros::spinOnce(); rate.sleep(); }
    ROS_INFO("System Ready. Prepare for Multi-Waypoint Mission!");

    // 变量初始化
    TaskState current_task = PREPARE;
    QuinticPoly traj_x, traj_y, traj_z;
    
    double start_x=0, start_y=0, start_z=0, start_yaw=0;
    double takeoff_z_target = 0;
    
    // --- 多航点控制变量 ---
    int wp_index = 0; // 当前正在飞第几个航点
    int total_wps = MISSION_WAYPOINTS.size(); // 总航点数
    
    ros::Time task_start_time = ros::Time::now();
    ros::Time last_req_time = ros::Time::now();

    while(ros::ok()){
        ros::spinOnce();

        mavros_msgs::PositionTarget raw_target;
        raw_target.header.stamp = ros::Time::now();
        raw_target.coordinate_frame = mavros_msgs::PositionTarget::FRAME_LOCAL_NED;

        switch (current_task) {

            // ------------------------------------------------
            // 阶段 0: 预热 + 自动启动
            // ------------------------------------------------
            case PREPARE: {
                raw_target.type_mask = 0b101111111000; 
                raw_target.position = current_pose.pose.position;
                raw_target.yaw = calculate_yaw(current_pose.pose.orientation);

                if (ros::Time::now() - task_start_time > ros::Duration(TIME_WARMUP)) {
                    if(current_state.mode != "OFFBOARD" && (ros::Time::now() - last_req_time > ros::Duration(5.0))){
                        mavros_msgs::SetMode offb_set_mode;
                        offb_set_mode.request.custom_mode = "OFFBOARD";
                        if(set_mode_client.call(offb_set_mode) && offb_set_mode.response.mode_sent) ROS_INFO("Offboard enabled");
                        last_req_time = ros::Time::now();
                    } 
                    else if(!current_state.armed && (ros::Time::now() - last_req_time > ros::Duration(5.0))){
                        mavros_msgs::CommandBool arm_cmd;
                        arm_cmd.request.value = true;
                        if(arming_client.call(arm_cmd) && arm_cmd.response.success) ROS_INFO("Vehicle armed");
                        last_req_time = ros::Time::now();
                    }
                }

                if (current_state.mode == "OFFBOARD" && current_state.armed) {
                    ROS_INFO("Taking Off...");
                    start_x = current_pose.pose.position.x;
                    start_y = current_pose.pose.position.y;
                    start_z = current_pose.pose.position.z;
                    start_yaw = calculate_yaw(current_pose.pose.orientation);
                    takeoff_z_target = start_z + TAKEOFF_HEIGHT;
                    current_task = TAKEOFF;
                }
                break;
            }

            // ------------------------------------------------
            // 阶段 1: 垂直起飞
            // ------------------------------------------------
            case TAKEOFF: {
                raw_target.type_mask = 0b101111111000;
                raw_target.position.x = start_x;
                raw_target.position.y = start_y;
                raw_target.position.z = takeoff_z_target;
                raw_target.yaw = start_yaw;

                // 起飞完成，准备飞第0个航点
                if (std::abs(current_pose.pose.position.z - takeoff_z_target) < 0.1) {
                    ROS_INFO("Takeoff Done. Starting Waypoint 0...");

                    // 重新抓取当前位置作为第0段轨迹的起点
                    start_x = current_pose.pose.position.x;
                    start_y = current_pose.pose.position.y;
                    start_z = current_pose.pose.position.z;
                    
                    // 初始化航点索引
                    wp_index = 0;

                    // 规划去第一个点的轨迹
                    if (total_wps > 0) {
                        traj_x.compute(start_x, MISSION_WAYPOINTS[wp_index].x, MISSION_WAYPOINTS[wp_index].duration);
                        traj_y.compute(start_y, MISSION_WAYPOINTS[wp_index].y, MISSION_WAYPOINTS[wp_index].duration);
                        traj_z.compute(start_z, MISSION_WAYPOINTS[wp_index].z, MISSION_WAYPOINTS[wp_index].duration);
                        
                        task_start_time = ros::Time::now();
                        current_task = TRAJECTORY;
                    } else {
                        // 如果任务列表是空的，直接悬停
                        ROS_WARN("No waypoints! Hovering.");
                        task_start_time = ros::Time::now();
                        current_task = HOLD;
                    }
                }
                break;
            }

            // ------------------------------------------------
            // 阶段 2: 多点轨迹执行 
            // ------------------------------------------------
            case TRAJECTORY: {
                double t = (ros::Time::now() - task_start_time).toSec();
                double current_duration = MISSION_WAYPOINTS[wp_index].duration;
                
                // 判断当前航点是否飞完
                if (t > current_duration) {
                    t = current_duration; 
                    
                    // 检查是否还有下一个航点
                    if (wp_index < total_wps - 1) {
                        // --- 切换到下一个航点 ---
                        wp_index++; 
                        ROS_INFO("Waypoint %d reached. Moving to Waypoint %d...", wp_index-1, wp_index);

                        // 把当前位置设为新起点
                        // (为了平滑，建议用理论终点作为新起点，或者用当前真实位置)
                        // 这里使用理论终点(target)作为新起点，保证轨迹数学上的连续性
                        start_x = MISSION_WAYPOINTS[wp_index-1].x;
                        start_y = MISSION_WAYPOINTS[wp_index-1].y;
                        start_z = MISSION_WAYPOINTS[wp_index-1].z;

                        // 规划新轨迹
                        traj_x.compute(start_x, MISSION_WAYPOINTS[wp_index].x, MISSION_WAYPOINTS[wp_index].duration);
                        traj_y.compute(start_y, MISSION_WAYPOINTS[wp_index].y, MISSION_WAYPOINTS[wp_index].duration);
                        traj_z.compute(start_z, MISSION_WAYPOINTS[wp_index].z, MISSION_WAYPOINTS[wp_index].duration);

                        task_start_time = ros::Time::now(); // 重置计时器
                        t = 0; // 重置t
                    } 
                    else {
                        // --- 所有航点都飞完了 ---
                        ROS_INFO("All Waypoints Finished. Hovering...");
                        task_start_time = ros::Time::now();
                        current_task = HOLD;
                    }
                }

                raw_target.type_mask = 0; // P+V+A
                raw_target.position.x = traj_x.get_pos(t);
                raw_target.position.y = traj_y.get_pos(t);
                raw_target.position.z = traj_z.get_pos(t);
                raw_target.velocity.x = traj_x.get_vel(t);
                raw_target.velocity.y = traj_y.get_vel(t);
                raw_target.velocity.z = traj_z.get_vel(t);
                raw_target.acceleration_or_force.x = traj_x.get_acc(t);
                raw_target.acceleration_or_force.y = traj_y.get_acc(t);
                raw_target.acceleration_or_force.z = traj_z.get_acc(t);
                raw_target.yaw = start_yaw; 
                break;
            }

            // ------------------------------------------------
            // 阶段 3: 最终悬停
            // ------------------------------------------------
            case HOLD: {
                double t_hold = (ros::Time::now() - task_start_time).toSec();
                
                // 保持在最后一个航点的位置
                int last_idx = total_wps - 1;
                if (last_idx < 0) last_idx = 0; // 防御性检查

                raw_target.type_mask = 0b101111111000;
                raw_target.position.x = MISSION_WAYPOINTS[last_idx].x;
                raw_target.position.y = MISSION_WAYPOINTS[last_idx].y;
                raw_target.position.z = MISSION_WAYPOINTS[last_idx].z;
                raw_target.yaw = start_yaw;

                if (t_hold > TIME_HOVER) {
                    ROS_INFO("Hover time up. Landing...");
                    current_task = LAND;
                }
                break;
            }

            case LAND: {
                mavros_msgs::CommandTOL land_cmd;
                if (land_client.call(land_cmd) && land_cmd.response.success) {
                    ROS_INFO("Auto Land Triggered.");
                    current_task = FINISHED;
                } else {
                    ros::Duration(1.0).sleep(); 
                }
                break;
            }

            case FINISHED:
                break;
        }

        if (current_task != FINISHED && current_task != LAND) {
            target_pub.publish(raw_target);
        }

        rate.sleep();
    }
    return 0;
}